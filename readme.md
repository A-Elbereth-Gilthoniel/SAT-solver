# SAT-решатель

## Описание
SAT-решатель имеет задачу проверить, существует ли решение у булевой формулы, данной в формате конъюнктивной нормальной формы (КНФ)

Программа написана на языке программирования C++.

SAT-решение основано на алгоритме Сonflict-Driven Сlause Learning (CDCL) и имеет следующие приемы:
* Поиск уникальной точки импликации (UIP) в случае конфликта и Clause-learning
* Ленивый просмотр литералов - 2-Watched Literals
* Эвристика выбора переменных - чередование VSIDS и случайного выбора

## Компиляция и запуск

```C
>>> make
>>> ./prog ./<folder>/<file>.cnf
```
Запуск тестов

```C
>>> chmod +x test.sh
>>> test.sh <folder>
```

Очистка объектных и исполняемого файла

```C
>>> make clean
```

## Соответствие требованиям
* Рекурсия не используется
* Время решения задачи hanoi4.cnf - 4,510 сек.
* Потребление памяти при решении задачи hanoi4 - примерно 3.47 МБ.
* Задачи из набора uf150-645 решаются за 6 мин 19.631 сек

## Подробное описание реализации алгоритма C++

* **Вход**: Булева формула в формате КНФ (файл .cnf)
* **Выход**: SAT/UNSAT

### Структуры
1) [__assignment_info__](src/structures.h#L1) - информация о присваивании каждой переменной. Компоненты:
    - `bool value` - истинность переменной (true или false)
    - `int level` - Уровень принятия решения, на котором переменная была назначена
    - `int reason_clause_index` - Индекс клаузы, приведшей к присваиванию
    - `bool active` - Флаг, была ли переменная назначена
2) [__Clause__](src/structures.h#L8) - Модель клаузы (предложения) в CNF. Компоненты
    - `std::vector<int> literals` - литералы в предложении (положительные или отрицательные)
    - `int watched1; int watched2;` - литералы, над которыми ведется наблюдение (для алгоритма 2-watched literals)

### Класс [CDCL](src/algo.h#L1)
Основной класс, реализующий алгоритм __Conflict-Driven Clause Learning__. Переменные
- `size_t variable_amount` - число переменных в задаче
- `size_t clause_amount` - число предложений
- `std::deque<int> propagation_queue` - Очередь литералов для unit-пропагации
- `std::vector<Clause> clauses` - все предложения
- `std::vector<std::vector<int>> watched_map` - массив соответствий "литерал" -> "индексы предложений, в которых осуществляется слежка за литералом"
- `std::vector<assignment_info> var_conditions` - Состояние каждой переменной
- `std::stack<int> condition_stack` - Стек назначенных переменных для backtrack (возврат к предыдущим уровням)
- `int current_level` - Текущий уровень принятия решений
- `std::vector<double> activity` - Активности переменных для VSIDS-эвристики
- `double bump` - текущее приращение для VSIDS
- `short random_counter` - счетчик, с помощью которого выбирается эвристика.

### Функции

#### [process_algorithm()](src/cdcl.cpp#L25) - основная функция
Реализует основной CDCL-цикл. Возвращает false в случае, если выражение нерешаемо, и true в противном случае.
```C++
current_level = 0        // начальный уровень принятия решений
while (true)
    unit_propagate();    // unit-пропагация и анализ конфликта
    if (конфликт)
        if (нулевой уровень принятия решений)
            return false;
        analyze_conflict();    // анализ конфликта
        increase_activity();   // пересчет активности для VSIDS-эвристики
        compute_backjump_level(); // вычисление уровня, к которому следует откатиться
        backjump();            // возврат к другому уровню принятия решения
        add_clause()            // добавление обученного предложения к КНФ
        assign_literal(uip);   // объявление uip-переменной
        continue;
    if (все предложения решаемы)
        return true;
    choose_variable();    // VSIDS или случайный выбор
    if (все переменные объявлены)
        return false

    current_level++;
    assign_literal(следующая переменная); // объявление переменной, полученной с помощью choose_variable()

```

### [unit_propagate(int& conflict_clause_index)](src/cdcl.cpp#L165)
* Вход: переменная-индекс конфликтного предложения для изменения по ссылке
* Выход: true, если конфликтов не обнаружено, и false в противном случае

Производит логический вывод: если дизъюнкция содержит только один неназначенный литерал, то этот литерал должен быть истинным.

 Использует __схему двух наблюдаемых литералов__ (2-Watched Literals) для оптимизации:

- при каждом назначении `lit`, проверяются все дизъюнкции, где наблюдается `¬lit`
- если ни один другой литерал не может быть наблюдаем, и оставшийся наблюдаемый литерал ложен, фиксируется конфликт.

```C++
while (есть изменения в КНФ)
    while (propagation_queue не пуста)
        lit = propagation_queue.pop_front();
        for (каждое предложение, где наблюдается -lit)
            if (можно заменить наблюдение с -lit на другой литерал)
                обновляем watched_map;
            else
                if (второй наблюдаемый литерал - ложный)
                    conflict_clause_index = индекс предложения;
                    return false;
                else if (трушный)
                    continue;
                else if (не назначен)
                    назначить;
return true;
```
### [analyze_conflict(int conflict_clause_ind)](src/cdcl.cpp#L265)
* Вход: индекс предложения, в котором был обнаружен конфликт
* Выход: новое обучающее предложение

Анализирует конфликт с помощью прохода по графу импликаций:
1) начинается с предложения, вызвавшего конфликт;
2) последовательно раскрываются причины назначения переменных текущего уровня;
3) Итогом является обучающее предложение, содержащая ровно один литерал текущего уровня (UIP).

```C++
объявляем seen_vars, stack, new_clause2;
добавить переменные из конфликтной дизъюнкции в seen_vars, new_clause2, и переменные текущего уровня в stack;
while (current_level_vars не пуст)
    var = stack.pop()
    if (есть причинное предложение)
        for (lit по причинному предложению)
            if (lit нет в seen_vars)
                добавить литерал lit в seen_vars и new_clause2;
                if (lit.level == current_level)
                    stack.push(lit);
    удалить var из new_clause2;
for (lit по new_clause2)
    learned_clause.push(-lit);
return learned_clause;
```

### [compute_backjump_level(const std::vector<int>& learned_clause)](src/cdcl.cpp#L315)
* Вход: обучающая клауза из analyze_conflict
* Выход: уровень, которому надо откатиться и литерал текущего уровня(UIP)

Находит уровень, к которому нужно откатиться:
1) вычисляется максимальный и второй по величине уровень среди переменных в обучающем предложении;
2) откат выполняется ко второму максимуму;
3) литерал с максимальным уровнем (UIP) будет назначен после отката.

```C++
max_level = -1;
second_max = -1;

for (lit по learned_clause)
    level = var_conditions[|lit|].level;
    if (level > max_level)
        second_max = max_level;
        max_level = level;
        uip = lit;
    else if (level > second_max)
        second_max = level;
    return (second_max, uip);
```

### [backjump(int new_level)](src/cdcl.cpp#L344)
* Вход: уровень отката
* Выход: -

Сбрасывает все назначения, сделанные на уровнях выше new_level. Очередь литералов и стек назначенных переменных обрезаются, переменные помечаются как неактивные.

### [assign_literal(int lit, int reason_clause_index)](src/cdcl.cpp#L156)
* Вход: литерал и индекс причинного предложения
* Выход: -

Присваивает значение переменной, соответствующее литералу lit. Добавляет литерал в Очередь литералов и стек назначенных переменных. Фиксирует причину назначения.

### [add_clause(std::vector<int>& disjunct)](src/cdcl.cpp#L73)
* Вход: новое предложение
* Выход: -
Добавляет предложение к списку КНФ clauses:
    1) если длина предложения ≥ 2 — отмечаются два наблюдаемых литерала;
    2) если 1 — отмечается один литерал;
    3) обновляются списки наблюдений watched_map.

### [choose_variable()](src/cdcl.cpp#L105)
* Вход: -
* Выход: номер выбранной неназначенной переменной и 0, если все переменные назначены

Выбирает следующую переменную для назначения:
1) с вероятностью 1/10 выбирается первый неназначенный литерал
2) в остальных случаях используется эвристика активности (VSIDS) — переменные, участвующие в недавних конфликтах, получают больший приоритет

```C++
random_counter++;
if (random_counter >= 10)
    return первый неназначенный литерал;
else
    indices = массив с сортировой переменных по активности - от самого активного к менее;
    for (var по indices)
        if (var не назначена)
            return var;
if (все переменные назначены)
    return 0;
```

### [increase_activity(int conflict_clause_index)](src/cdcl.cpp#L147)
* Вход: индекс предложения, в котором обнаружен конфликт
* Выход: -

Увеличивает активность переменных, участвующих в конфликтной дизъюнкции.

```C++
for (lit по clauses[conflict_clause_index])
    activity[|lit|] += bump;
bump /= 0.95;
```
### Вспомогательные функции

- [is_satisfied(const std::vector<int>& clause)](src/cdcl.cpp#L93) - проверяет, истино ли предложение (хотя бы один литерал истинен).

- [lit_is_assigned(int lit)](src/cdcl.cpp#L240) - проверяет, назначен ли литерал.

- [lit_is_false(int lit)](src/cdcl.cpp#L247) - проверяет, ложен ли литерал.

- [lit_is_true(int lit)](src/cdcl.cpp#L256) - проверяет, истинен ли литерал.
